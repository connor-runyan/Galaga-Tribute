More on Components & Architecture!
    - Resource management:
        - System responsible for manipulating content/assets
            - i.e sound, animation, models, etc.
        - Optimizes usage of resources
        - Asset streaming (prediction of usage)
            - Game engine is predicitively loading assets and things
    
        - Game developers have historically preferred to write their own memory management, rather than using
            the standard libraries
            - Object Pools:
                - Pre-allocated objects/assets in memory
                - Rather than needing to use the resources to allocate memory for these, 
                    the memory manager can pull these pre-allocated items in
    - Rendering:
        - Interface to low-level API for drawing things
            - low level APIs like DirectX, OpenGL, etc.
        - Handles things like screen resolution, apsect ration, colors
        - Font Rendering
        - Hierarchy of rending engines (From lowest to highest):
            - Video Card GPU
                - OpenGL, Vulkan, DirectX, etc.
                    - Abstraction Layer on top of those APIs
                        - Low-level API (for game-engine) -> Renders models
                            - High-level API -> plays animation
                                - Game Engine
                                    - Gameplay Code
        - Features:
            - Scene Graph:
                - things such as buildings, scenerey, etc.
            - 2D & 3D Rendering
            - Camera models
            - Offline Rendering
    - Audio:
        - Like the video rendering, has an interface to a low-level API
    - Input:
        - Keyboard
        - Mouse (+Motion Smoothing, as human movement is really jerky)
    - Networking:
        - Sharing game data
        - Multiplayer
        - Social communities
        - Challenges:
            - TCP/IP data transfer
            - Packet loss
            - Latency
            - Bandwidth
            - Synchronization of game state
    - Physics engines
    - Scripting
        - glue between game and game engine
    - Artificial Intelligence:
        - Collection of techniques used to produce the illusion of Intelligent behavior in non-player controlled game characters
        - Things that can be included to help with this:
            - actions
            - information gathering
            - goals, planning
            - path finding
            - finite-state machines

Game Loop: (See Dean's example in the slides)
    Steps:
        1 - Initialize game (One time initialization)
            - Loads graphics
            - take initial time-stamp (call it previous_time_stamp)
        MAIN LOOP:
            2 - Process Input
            3 - Update Game Logic
                - Take current time-stamp (compute elapsed time)
                - update based on elapsed time
            4 - render game state
        5 - Move time-stamp to previous time-stamp
        6 - If done, move to step 7, else back to 2
        7 - terminate
    Timing:
        - Wall clock-time:
            - real world elapsed time
        - Simluation time:
            - how much game-play time has passed (from when the game was initialized)
            - Not always the same as wall-clock time
                - Example (Bullet time):
                    - game frame-rate stays the same
                    - game Simluation slows down
                    - player continues to react in real-time 
    Moving objects:
        - BAD IDEA: Move some number of units per frame
            - Results in increasing speed of objects
        - Best idea:
            - take elapsed time a 
                X_2 = X_1 + v delta_t (x_2 is new location, x_1 is old position, v is velocity, delta_t is elapsed (time changed between frames))



More on the game loop:
    Frame rate matters not only for visual processing, but also because of how fast input is processed.objects


Game Loop Assignment:
    - Loop is running at one tick per millisecond
    - Render only shows the things that have been reported to be rendered
        - Removes things from the queue
    - Update loop is the one doing all the logic determining what should be rendered
    - Add event is asynchronous (just use the JS onpressed button, put stuff in the array of inputs)
        - Because of the way JS works, if input is given in the middle of the loop, it wont be processed until after the 
            request animation frame function is called.
    - Timestamp returned from requestAnimationFrame is NOT the elapsed time.
    - Remove expired events from the array/queue

Rendering:
    - Canvas Rendering
        - Example of canvas element:
            <canvas width="500" height="500"></canvas>
                - Defines the size of the coordinate system of the canvas
                - Visually, this can be changed using CSS. 
                - Coordinate system:
                    - Upper Left (0,0)
        - JS -> HTML connection:
            let canvas = document.getElementById('canvas-id')
            let context = canvas.getContext('2d')
        - Clearing canvas:
            - context.clearRect(start_x, start_y, width, height)
            *** This is done at the beginning of every rendering of every frame

    - Drawing a rectangle:
        1 - Set rendering styles
            - See Canvas documentation for possible styles
            - IMPORTANT!!! When using complex styles (i.e. shadows), save the context state then restore after it's been used
                - This is basically like post script.
        2 - Fill (optional)
        3 - Draw (optional)
            - When drawing straight lines, be aware that odd pixel widths need to be offset by 0.5.
    - Drawing polygons:
        - Similar to how it's done in Postscript:
            - i.e. with moveTo and lineTo functions

    - Rotating Shapes:
        Very similar to translation in Postscript:
            - the bottom left of the canvas is translated to the center of the shape
            - Rotate the canvas
            - translate back
            - Draw the box
            - Unrotate the canvas (revert contaxt back with context.restore())